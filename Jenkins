- We need to build an executable file out of this git.
- This is called CI.
- The famous tool we use is Jenkins.
- We use jenkins with Maven to build to the code.
- We take the raw code from the developer we check whether unit test cases are running or not or is getting compiled or not.
- All these things we check we integrate the code.
- Once the code is ready we need to host it.
- We need to deploy the code we need to setup and infrastructure.
- Take a machine install Java, install Tomcat and then dependencies copy the code and then deploy the code.
- We need to setup and infrastructure.
- We need CM tools to make changesto our infrastructure that is called CM.
- Once the environment is setup we use containers to host the applications like .war files or tomcat or app we use containers.
- We are packaging together and runnng it as a container.
- We are using Docker and container to manage the apps.

------------------------------------------------------------------------------------------------------------------------------------

- What are shared libraries in Jenkins?
- Shared libraries in Jenkins enable the reuse of scripts, steps, and variables across multiple Pipeline jobs.
- Candidates should explain how they can define these libraries once and then reference them in Jenkinsfiles, which reduces code duplication.
- Look for explanations of how to set up a shared library by adding it to the Jenkins configuration and referencing it in a Pipeline script using the @Library annotation or
  the libraries section in a Declarative Pipeline.
------------------------------------------------------------------------------------------------------------------------------------

- How would you implement blue/green deployments using Jenkins?
- Blue/green deployments help reduce downtime and risk by running two identical environments ("blue" and "green") and switching traffic from one to the other after new changes 
are tested and ready.

- Developers need to deploy new versions to the inactive environment, perform health checks and tests, and then switch the traffic (often via load balancers). 
- Skilled candidates would also mention rollback strategies they’d set up to prevent issues.


- How do you integrate static code analysis tools into a Jenkins pipeline?
- Static code analysis tools, such as SonarQube, Checkstyle, or FindBugs, help automatically analyze source code for potential errors, code smells, or security vulnerabilities.
- To integrate static code analysis tools into a Jenkins pipeline, developers use plugins for each tool. For this, they would need to:
- Install the plugin through the Jenkins management interface.
- In the pipeline configuration (either for a Declarative or Scripted Pipeline), add steps to execute the static code analysis during the build process.
- Configure the pipeline to analyze the results, potentially fail the build on violations, and display the results directly within the Jenkins UI for review.
- This automates code quality checks and ensures that code standards are consistent.

- How can Jenkins be used for monitoring applications?
- Jenkins is ideal for monitoring build statuses and performance metrics, plus, it integrates well with external monitoring tools.
- Candidates might mention using Jenkins plugins to push build logs and metrics to centralized logging and monitoring tools like ELK (Elasticsearch, Logstash, Kibana) or Splunk.
- They would set up notifications (for example, via email or Slack) based on build outcomes or metrics thresholds and might also use Jenkins Pipeline steps to embed monitoring 
  and logging checks directly within CI/CD processes.

------------------------------------------------------------------------------------------------------------------------------------

Parallel jobs in Jenkins mean multiple jobs or job stages run simultaneously, instead of waiting for each other to complete.

- Where it's used:
- In Pipelines, using parallel block to run stages together.

- In Matrix jobs, testing across multiple environments.

- In multi-configuration projects or distributed builds (e.g., on multiple agents).

- Why it's useful:
- Speeds up builds by doing tasks like testing, linting, or deploying in parallel.

- Efficient resource use across multiple agents.
- Example (Declarative Pipeline):
pipeline {
  agent any
  stages {
    stage('Parallel Tasks') {
      parallel {
        stage('Unit Tests') {
          steps {
            echo 'Running unit tests...'
          }
        }
        stage('Lint Check') {
          steps {
            echo 'Running lint checks...'
          }
        }
      }
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------

- Yes, Jenkins build agents can be deployed as Docker containers. 
- This is a common and scalable method used in modern CI/CD setups.

✅ Why use Docker for Jenkins agents?
- Isolation: Each agent runs in its own container.
- Consistency: Same environment across builds.
- Scalability: Easily spin up/down agents.
- Easy cleanup: Containers can be removed after builds.

- How to deploy?
- Install Docker on the Jenkins host
- Install Docker plugin in Jenkins
- Define Docker agent template in Jenkins (e.g., via Docker plugin or JCasC)
- Use a Docker image for the agent (e.g., jenkins/inbound-agent)
- Configure pipeline to use Docker agent:
pipeline {
  agent {
    docker {
      image 'maven:3.8.4-openjdk-17'
    }
  }
  stages {
    stage('Build') {
      steps {
        sh 'mvn clean install'
      }
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------

Option 1: Docker Compose Setup
docker-compose.yml

version: '3'

services:
  jenkins:
    image: jenkins/jenkins:lts
    user: root
    ports:
      - "8080:8080"
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DOCKER_HOST=unix:///var/run/docker.sock

volumes:
  jenkins_home:

2. Inside Jenkins:
Install: Docker and Docker Pipeline plugins.

Pipeline example

pipeline {
  agent {
    docker {
      image 'node:18'
    }
  }
  stages {
    stage('Build') {
      steps {
        sh 'node -v'
      }
    }
  }
}

Option 2: Kubernetes Jenkins Agent
1. Prerequisites:
Jenkins on Kubernetes (via Helm)

Kubernetes plugin installed

Jenkins service account with permissions to spawn pods

2. Pod template snippet (in Jenkins > Manage Jenkins > Cloud > Kubernetes):
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: jenkins-agent
spec:
  containers:
  - name: jnlp
    image: jenkins/inbound-agent
    args: ['$(JENKINS_SECRET)', '$(JENKINS_NAME)']
  - name: maven
    image: maven:3.8.4-openjdk-17
    command:
    - cat
    tty: true

3. Jenkinsfile:
pipeline {
  agent {
    kubernetes {
      yamlFile 'pod-template.yaml'
    }
  }
  stages {
    stage('Build') {
      steps {
        container('maven') {
          sh 'mvn -v'
        }
      }
    }
  }
}

------------------------------------------------------------------------------------------------------------------------------------

Here’s a Helm + YAML setup to deploy Jenkins with Docker-based agents on Kubernetes:

helm repo add jenkins https://charts.jenkins.io
helm repo update

helm install jenkins jenkins/jenkins \
  --namespace jenkins --create-namespace \
  --set controller.adminUser=admin \
  --set controller.adminPassword=admin \
  --set controller.serviceType=LoadBalancer \
  --set controller.installPlugins[0]=kubernetes:latest \
  --set controller.installPlugins[1]=workflow-aggregator:latest \
  --set controller.installPlugins[2]=docker-workflow:latest \
  --set controller.installPlugins[3]=blueocean:latest \
  --set controller.installPlugins[4]=git:latest

Step 2: Give Jenkins RBAC to Launch Pods
Create jenkins-rbac.yaml:
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: jenkins
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: jenkins-role-binding
  namespace: jenkins
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: jenkins
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io

Apply it
kubectl apply -f jenkins-rbac.yaml

Step 3: Configure Pod Template in Jenkins UI
Jenkins → Manage Jenkins → Configure Clouds → Kubernetes

Paste this YAML in the Pod Template:
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: agent
spec:
  containers:
    - name: jnlp
      image: jenkins/inbound-agent
      args: ['$(JENKINS_SECRET)', '$(JENKINS_NAME)']
    - name: docker
      image: docker:24.0.2
      command:
        - cat
      tty: true

Step 4: Pipeline using Kubernetes Agent
pipeline {
  agent {
    kubernetes {
      yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
    - name: docker
      image: docker:24.0.2
      command:
        - cat
      tty: true
    - name: jnlp
      image: jenkins/inbound-agent
      args: ['$(JENKINS_SECRET)', '$(JENKINS_NAME)']
'''
    }
  }
  stages {
    stage('Run Docker') {
      steps {
        container('docker') {
          sh 'docker --version'
        }
      }
    }
  }
}

