- Problem: Two Sum.
- Goal: Find two numbers in the array that add up to a given target, and return their indices.

- Simple Explanation (Line by Line):
- Step-by-step plan:
- Youâ€™re given:

- An array of integers nums.

- A target number.

- You need to find:

- Two numbers in nums whose sum = target.

- Return their indices, not the numbers themselves.

- Example:
- nums = [2, 7, 11, 15]
- target = 9

- Explanation:

- 2 + 7 = 9

- Their indices are [0, 1]

- Optimal Code (Python):
def twoSum(nums, target):
    hashmap = {}  # Store numbers weâ€™ve seen and their indices
    for i, num in enumerate(nums):
        complement = target - num  # What number do we need to make the sum?
        if complement in hashmap:
            return [hashmap[complement], i]  # Found the two numbers
        hashmap[num] = i  # Store this number with its index

Line-by-Line Breakdown:
hashmap = {}

ðŸ‘‰ Create an empty dictionary.
ðŸ‘‰ It will store {number: index} pairs
ðŸ‘‰ Helps to find if we've already seen the number we need.

- for i, num in enumerate(nums):
- Loop over the array with index i and value num

- complement = target - num

- Calculate the number you need to reach the target.
ðŸ‘‰ Example: If target=9 and num=2, you need 9-2 = 7

- if complement in hashmap:
- Check if we already saw the number we need earlier.
ðŸ‘‰ Example: If 7 is already in hashmap, we now have both numbers

- return [hashmap[complement], i]
- Return the indices:

- hashmap[complement] gives index of the earlier number

- i is the current index

- hashmap[num] = i

- Store the current number and its index in case it's needed later.

- Test Example:
- nums = [3, 2, 4]
- target = 6

- Step 1: hashmap = {}
- Step 2: i=0, num=3 â†’ complement = 3 â†’ not in hashmap â†’ store 3:0
- Step 3: i=1, num=2 â†’ complement = 4 â†’ not in hashmap â†’ store 2:1
- Step 4: i=2, num=4 â†’ complement = 2 â†’ 2 is in hashmap â†’ return [1,2]

- Output:
- python
- [1, 2]


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Problem: Valid Parentheses
- Youâ€™re given a string s with only brackets: (), {}, []
- You must check if itâ€™s valid:

- Every open bracket must have a matching closing bracket.

- Brackets must be closed in the correct order.

- Key Idea: Use a stack
- Why a stack?
- It follows Last In, First Out (LIFO) â€” perfect for tracking open brackets.

- Python Code:
- python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in mapping:  # If it's a closing bracket
            top = stack.pop() if stack else '#'  # Get last open bracket
            if mapping[char] != top:
                return False  # Doesn't match
        else:
            stack.append(char)  # It's an open bracket

    return not stack  # Return True if stack is empty (all matched)

- Line-by-Line Breakdown:
- python
stack = []

- Create an empty list to use as a stack.

- python
- mapping = {')': '(', '}': '{', ']': '['}

- Define what each closing bracket should match.

- python
for char in s:

- Loop through each character in the input string.

- python
if char in mapping:

- Check if itâ€™s a closing bracket like ), ], }.

- python
top = stack.pop() if stack else '#'

- Try to pop the last open bracket.
- If stack is empty (nothing to match), use # to force a mismatch.

- python
if mapping[char] != top:
    return False

- If the closing bracket doesnâ€™t match the last open bracket â†’ invalid.

- python
else:
    stack.append(char)

- If itâ€™s an open bracket, just add it to the stack.

- python
- return not stack

- If stack is empty â†’ all brackets matched â†’ return True.
- If stack has leftover open brackets â†’ return False.

ðŸ§ª Example: s = "([])"
( â†’ push â†’ stack: [(]

[ â†’ push â†’ stack: [(, []

] â†’ pop [ â†’ matches â†’ continue

) â†’ pop ( â†’ matches â†’ continue
âœ… stack empty â†’ return True

